\chapter{Software Design and Development}
\label{chap:software-design}

To implement the 3D MOC solver, the work in this thesis uses the OpenMOC~\cite{openmoc} neutron transport code, which was developed for 2D MOC simulations. Due to its strict focus on 2D simulations, great work was required to extend OpenMOC to 3D MOC calculations. This chapter explains the structure of OpenMOC and the changes that were necessary to increase code flexibility in order to accommodate 3D MOC calculations. This chapter begins with a general overview of OpenMOC in Section~\ref{sec:openmoc-overview}, with a focus on the Constructive Solid Geometry (CSG) representation of geometric detail. The interested reader can find a more complete description of the OpenMOC code in Boyd's thesis~\cite{boyd2014openmoc}. Next, the object oriented design is discussed in greater detail in Section~\ref{sec:object-oriented} with a focus on the changes to accommodate both 2D and 3D simulations. This discussion is continued in Section~\ref{sec:modular-structure}, where the new modular structure of OpenMOC is discussed as well as its importance in creating a robust simulation tool capable of supporting various algorithms. In Section~\ref{sec:user-input} the standard Python user input is discussed as well as the new C++ alternative build which is attractive for high performance computing (HPC) applications where the availability of software required for the Python interface may be limited. Section~\ref{sec:version-control} concludes the chapter with a discussion of development practices and the open source license.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{OpenMOC Overview}
\label{sec:openmoc-overview}

OpenMOC is neutron transport code that is written in C++ with a Simplified Wrapper Interface Generator (SWIG)~\cite{swig} to expose the C++ classes and routines to the Python scripting language. This allows users to take advantage of the simplicity and flexibility of the Python language while also having the performance benefits of C++ compiled code. In this way, users can work entirely in Python without having to touch the underlying C++ code. In addition, users do not have to learn a new input file syntax, only the names, functionality, and input variables of functions constituting the Application Programming Interface (API). This allows for users to write more natural code.

The underlying C++ code of OpenMOC also leverages the use of OpenMP~\cite{openmp} for shared memory parallelism. In this framework, all data is shared between threads on a single node. With the emergence of the 3D solver, distributed parallelism has also been implemented with MPI~\cite{mpi} in the form of domain decomposition, discussed in Chapter~\ref{chap:domain-decomposition}. With this hybrid parallelism design, OpenMOC is able to scale to both many CPU cores and many nodes. 

OpenMOC is built on the use of constructive solid geometry (CSG), which allow complex geometries to be built out of boolean operations -- such as intersections and unions -- of simple surfaces and building blocks termed \textit{primitives}. In addition, a hierarchy is used to agglomerate collections of primitives together. This approach is particularly useful for reactor geometries which are often highly structured. For example, a typical reactor core is built out of simple \textit{fuel pins}, grouped together into \textit{assemblies}. Fuel pins describe the radial detail of a fuel rod. Assemblies are then grouped together to form the reactor core. An example of a 2D CSG construction of a single assembly is given in Figure~\ref{fig:core-csg}.

\begin{figure}[h!]
	\centering
	\includegraphics[width=0.9\linewidth]{figures/assembly-csg.PNG}
	\caption[]{The hierarchical CSG construction of a typical assembly.}
	\label{fig:core-csg}
\end{figure}

One of the benefits of the CSG approach is a reduced memory requirements of storing the geometry. Instead of explicitly storing information of each fuel pin within the reactor core, only unique fuel pin types need to be stored. They are then referenced by their parent structure. For instance, an assembly contains an lattice of fuel pins. It would contain a mapping of location within the lattice to the unique fuel pin type, rather than the full information of each fuel pin.

In addition, the formation of a CSG allows ray tracing to be conducted in a general framework, agnostic of the individual primitives. Each \textit{cell} in OpenMOC is comprised of \textit{surface} objects and the half-space of each surface. A half-space determines on which side of the surface the cell is located. Ray tracing fundamentally involves calculating the distance to intersection along a direction. With the CSG framework, each of the bounding surfaces is queried for the distance to intersection. This naturally speeds up ray tracing by not having to check each instance of a surface within the geometry, but rather only the local surfaces. 

Once the geometry is built, OpenMOC generates tracks across the constructed geometry, and solves the neutron transport equation iteratively, as described in Chapter~\ref{chap:moc}. CMFD acceleration can also be included by the user, which employs the underlying methods that were described in Chapter~\ref{chap:cmfd}.

Once the neutron transport equation is solved, the solver can be queried to return the scalar flux distribution. In order to visualize the data, OpenMOC includes Python plotting routines for scalar flux data, computed reaction rates, as well as geometric detail and visual diagnostics. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Object Oriented Design}
\label{sec:object-oriented}

OpenMOC uses the object oriented programming paradigm whereby data structures called \textit{classes} are created that encapsulate both the data and associated subroutines. Object oriented programming generally leads to more resilient code since only the class itself can access its private attributes. An instantiation of a class is termed an \textit{object}. OpenMOC applies many of the principles of object oriented programming including information hiding, inheritance, and polymorphism.

An OpenMOC simulation requires three main components: a geometry, a track generator, and a solver. All of these are C++ classes in OpenMOC and exposed to the user. The user first describes the surfaces, cells, universes, and materials which constitute the geometry in a hierarchical CSG arrangement. The user then instantiates a \texttt{Geometry} object and provides it the root cell of the CSG. Next, a \texttt{TrackGenerator} is instantiated which is provided the \texttt{Geometry} object as well as track generation parameters such as radial ray spacing and number of azimuthal angles. Lastly, a \texttt{Solver} object is instantiated and provided the \texttt{TrackGenerator} object along with solver criteria such as the tolerance. The solver can then be called to solve the MOC equations, such as the MOC neutron transport eigenvalue problem, using the track and segmentation information found in the \texttt{TrackGenerator}.

Extending the OpenMOC solver to 3D simulations required restructuring all of these classes in order to make them more flexible. The goal in extending to 3D simulations was to still maintain the ability to run 2D simulations, if desired. A benefit of maintaining the ability to run 2D simulations is to allow the user to compare 2D and 3D simulations on the same problem. To accommodate this, the input structure between 2D and 3D simulations is very similar. In order to make the code more resilient and simpler, common code reuse was emphasized. Many of the routines present in the 2D simulations are also used in the 3D simulations so both should use the same code without re-writing those entire sections. These points illustrate the need for maximum cohesion between the 2D and 3D solver modes. This is accomplished by expanding the 2D classes to be more general.

\subsection{\texttt{Geometry} Class Updates}
\label{sec:oo-geometry}

The \texttt{Geometry} class was altered to accommodate piecewise \textit{extruded geometries}. Extruded geometries are configurations in which the geometry looks the same at every axial level. A piecewise extruded geometry is a geometry that can be formed as the union of a finite number of extruded geometries. For instance, a fuel rod with end caps would fit the description of an extruded geometry but a sphere would not. Most practical reactor applications are indeed piecewise extruded geometries so this is not a very strong limitation. 

With the change from 2D geometries to piecewise axially extruded geometries, circles are transformed to $z$-cylinders (cylinders with a vertical major axis) and $z$-planes are added with a similar structure to the $x$ and $y$ planes already incorporated in OpenMOC. With this new geometry paradigm, 2D problems are thought of as simulating a radial slice of a 3D geometry at a given $z$ height. 

\subsection{\texttt{TrackGenerator} Class Updates}
\label{sec:oo-trackgenerator}

With the updated \texttt{Geometry} class, the \texttt{TrackGenerator} class was updated to support 3D track generation and ray tracing. 2D ray tracing is imagined as ray tracing tracing perpendicular to the $z$-axis at some $z$-height. By default this height is assumed to be 0.0 in order to limit the complexity of user input for 2D simulations. The user can specify a different $z$-height using the \texttt{setZCoord} function of the \texttt{TrackGenerator} class.

For 3D simulations, a new \texttt{TrackGenerator3D} class was created which inherits from the \texttt{TrackGenerator} class. In object oriented programming, a class that inherits from a parent class has access to all the parent class data and subroutines. Since tracks are built on a 2D projection, the 3D track generator must have all the functionality of the regular 2D track generator. This is the typical paradigm where class inheritance is useful. 

During ray tracing, a \texttt{TrackGenerator3D} object first ray traces all 2D tracks (determined from the parent \texttt{TrackGenerator} functionality) over all potentially unique $z$-planes in the geometry to form the equivalent of a ray trace over the composite of all radial detail in the geometry. Since this can potentially be expensive, users are allowed to indicate the actual piecewise axially extruded ranges in the \texttt{Geometry} through the \texttt{setSegmentationZones} function in the \texttt{TrackGenerator3D} class. If these zones are not specified, all $z$-planes in the geometry are viewed as a potential divider between different axially extruded regions.

Once the 2D ray trace is conducted over all axially extruded regions, the full 3D ray trace can be calculated. Due to the expense of explicitly storing all 3D tracks in a typical geometry, the \texttt{TrackGenerator3D} class generates tracks on-the-fly. Similarly, segments can be prohibitively expensive to store. Therefore, the default mode is to calculate segments on-the-fly rather than upfront, although both options are available. Ray tracing and segmentation is discussed in greater detail in Chapter~\ref{chap:ray-tracing}.

\subsection{\texttt{Solver} Class Updates}
\label{sec:oo-solver}

The \texttt{Solver} class has also been reformulated to support both 2D and 3D simulations. The \texttt{Solver} class is an abstract class, meaning it contains the description of data and associated subroutines, but cannot be instantiated on its own. Instead, there are subclasses that inherit from the abstract class that can be instantiated. In this case the \texttt{CPUSolver} and \texttt{GPUSolver} classes are both subclasses of the \texttt{Solver} class. Rather than supporting both the \texttt{CPUSolver} and \texttt{GPUSolver} classes, this thesis focuses on the \texttt{CPUSolver} class to allow for easier implementation of the object oriented structures.

The \texttt{CPUSolver} was altered to support the calculation of both 2D MOC and 3D MOC equations. By referring to the supplied \texttt{TrackGenerator} object, it can determine whether a 2D or 3D simulation should be calculated. If a \texttt{TrackGenerator3D} object was provided to the solver, it runs a 3D simulation. Otherwise, a 2D simulation is run. While much of the code is shared between the 2D and 3D simulations in the solver, the core code which calculates the variation of angular flux over segments has separate 2D MOC and 3D MOC code sections for efficiency.

In addition to the existing \texttt{CPUSolver}, a new \texttt{CPULSSolver} class has been added to OpenMOC which is capable of using a linear source approximation. Since the linear source solver needs much of the code present in the regular flat source solver, \texttt{CPULSSolver} was implemented as a subclass of \texttt{CPUSolver}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Modular Structure}
\label{sec:modular-structure}

In switching to a code that supports 2D in 3D simulations, it was quickly realized that without a massive overhaul, there would be a very large amount of repeated code. The goal was to create a code that was capable of conducting both 2D and 3D MOC simulations, but also compare multiple types of ray tracing and mathematical approximations (such as linear source). For all these options to be supported, there is the possibility for much of the same functionality to be implemented at multiple points in the code.

For example, MOC can largely be described as an algorithm that performs a ray trace then computes equations over the segments formed from the ray trace. Many different ray tracing algorithms could be used with the underlying equations and solver remaining theoretically unchanged. However, if the code is rigid, each new ray tracing algorithm would require an entire code re-write.

Therefore, a goal in developing OpenMOC to support work presented in this thesis is to maximize code reuse. This not only shortens the code but also makes it more robust as algorithms tend to change frequently to update functionality and fix bugs. If code is repeated, it is likely that not all of the code would receive the appropriate updates. Additionally, comparing options in the code, such as ray tracing, becomes much more robust since the code run during comparisons would only differ minimally with most of the differences being those directly being tested.

A structure was created in which segment traversal, ray tracing, and the algorithms that use segment information can be easily decoupled. In this new structure, \texttt{MOCKernel} classes dictate what operations to perform on each segment and a \texttt{TraverseSegments} class dictates how to iterate over segments and which ray tracing method to use. Both of these classes are virtual classes which have subclass implementations. A specific algorithm that uses segment information is meant to form a subclass of the \texttt{TraverseSegments} class, defining operations to perform on groups of segments. The algorithm should also specify which \texttt{MOCKernel} object should be used.

\subsection{\texttt{MOCKernel} Classes}

Since the \texttt{MOCKernel} class is meant to operate directly on segments, it often appears in the inner-most loop in algorithms. The \texttt{MOCKernel} parent class contains relevant information used for most of its subclass implementations. These attributes include:
\begin{itemize}
	\item A counter, counting the number of segments encountered by the kernel
	\item The maximum path length allows for segments before they must be split
	\item The number of energy groups
\end{itemize}

An \texttt{MOCKernel} class also has a few virtual functions that must be implemented by subclasses. Notable functions include:
\begin{itemize}
	\item An \texttt{execute} function which dictates what to do on a segment
	\item A \texttt{newTrack} function that dictates functionality when a new group of segments is encountered.
\end{itemize}
The \texttt{execute} function is applied immediately when a segment is formed from ray tracing (or loaded in the case of explicitly stored segments) whereas the \texttt{newTrack} function is applied at the start of sequencing through a group of segments. The segments composing a track is an example of a common grouping of segments, though other groupings could be chosen.

Since the \texttt{MOCKernel} class is a virtual class, it is meant to have subclasses which can be instantiated. The current \texttt{MOCKernel} subclasses implemented in OpenMOC are:
\begin{itemize}
	\item \texttt{CounterKernel}: Counts the number of segments encountered by the kernel
	\item \texttt{VolumeKernel}: Uses track weights and segment lengths to form an estimate of the volumes of regions encountered
	\item \texttt{TransportKernel}: Directly applies the transport equation on the encountered segments
	\item \texttt{SegmentationKernel}: Caches segment information for use in later calculations
\end{itemize}
Since the \texttt{SegmentationKernel} object just caches information it is useful for complicated operations or operations which can be most efficient when applied to a bulk grouping of data. For this efficiency reason, the \texttt{TransportKernel} is not currently used in the default solver. Instead, a \texttt{SegmentationKernel} is used in its place so that the operations can be applied to flux data at once instead of interleaving ray tracing with transport calculations.

\subsection{\texttt{TraverseSegments} Classes}

Unlike the \texttt{MOCKernel} parent class, the \texttt{TraverseSegments} virtual class contains a significant amount of algorithmic information. Specifically, the virtual class contains all segment iteration and ray tracing algorithms. The algorithm has a \texttt{loopOverTracks} function that takes an \texttt{MOCKernel} as an argument. Subclasses of \texttt{TraverseSegments} can call this function which iterates over groups of segments (eg. tracks). 

Inside the \texttt{loopOverTracks} function, a conditional block calls the appropriate segment looping scheme, passing along the provided kernel. The currently implemented segment iteration schemes are:
\begin{itemize}
	\item \texttt{loopOverTracks2D}: Iteration scheme for looping over explicitly stored 2D segments
	\item \texttt{loopOverTracks3DExplicit}: Iteration scheme for looping over explicitly stored 3D segments
	\item \texttt{loopOverTracksByTrackOTF}: Iteration scheme for looping over and generating segments on-the-fly where segments in a track are looped over in order before switching to the next track
	\item \texttt{loopOverTracksByStackOTF}: Iteration scheme for looping over and generating segments on-the-fly where segments in a $z$-stack of tracks are looped over in order before switching to the next $z$-stack
\end{itemize}
Each of the iteration schemes loops over all tracks and segments in the problem in some order, performing the associated ray tracing algorithm when appropriate. The ray tracing scheme is provided information relevant to ray trace or load the segments of interest. In most cases, this pertains to all segments in a track. However, for the \texttt{loopOverTracksByStackOTF} scheme, all segments in a $z$-stack are traced at once. Before calling the ray tracing scheme, the \texttt{newTrack} function of the provided kernel is called. Then the ray tracing scheme is called and provided the kernel so that it can call the \texttt{execute} function immediately when the segment is formed or loaded. 

After the ray tracing scheme is completed, an \texttt{onTrack} function is called which details operations to perform on the group of segments. The cached segment information is also provided if a \texttt{SegmentationKernel} was used. The transport sweep algorithm currently used in OpenMOC applies all of the MOC equations inside the \texttt{onTrack} function using the provided cached segment information.

In general, algorithms which require track or segment information should form a small subclass of the \texttt{TraverseSegments} function and define the \texttt{onTrack} function. Additionally, an \texttt{execute} function should be defined which details the general structure of the algorithm. It should include the setup, call the \texttt{loopOverTracks} function to loop over all segments and apply the algorithm detailed by the \texttt{onTrack} function and the provided kernel, and then detail any operations to perform after looping over all tracks and segments. 

An example of an execute function is given below for the \texttt{VolumeCalculator} class which calculates the volumes of all regions in the geometry. Since it performs all operations directly on segments using \texttt{VolumeKernel} objects, the \texttt{onTrack} function is defined to simply return.

\begin{center}
\begin{lstlisting}
void VolumeCalculator::execute() {
	#pragma omp parallel
	{
		MOCKernel* kernel = getKernel<VolumeKernel>();
		loopOverTracks(kernel);
	}
}
\end{lstlisting}
\end{center}

For algorithms in which only operations need to be performed on tracks, a \texttt{NULL} kernel can be provided which alerts the segment iteration scheme to skip the ray tracing step. Numerous subclasses of \texttt{TraverseSegments} are present in OpenMOC since every algorithm which loops over segments or tracks is contained in a subclass of \texttt{TraverseSegments}. They all appear in the files \texttt{TrackTraversingAlgorithms.h} and \texttt{TrackTraversingAlgorithms.cpp}.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{User Input}
\label{sec:user-input}

In terms of input structure, the 3D MOC updates to OpenMOC were structured to minimize the amount of work required to convert a 2D input to a 3D input. From a fully defined 3D geometry, including $z$-planes, the only difference in input between a 2D and 3D simulation is the definition of the track generator. A regular 2D \texttt{TrackGenerator} object supplied to a solver will trigger the 2D MOC solver, whereas a \texttt{TrackGenerator3D} object will trigger the 3D MOC solver. Similarly, a \texttt{CPUSolver} object triggers the flat source solver, whereas a \texttt{CPULSSolver} object triggers the linear source solver.

If the Geometry was written in two dimensions without specifying $z$-planes, the geometry will need to be bounded in order to have a well defined 3D MOC problem. In theory, a 2D simulation implies infinite dimensions axially so if a bounded 3D geometry is provided to a regular 2D \texttt{TrackGenerator} object, a warning will be triggered, but the simulation will still run assuming infinite axial dimensions.

To facilitate running on systems which do not have thorough Python support or have difficulty transferring MPI communicator objects between Python and C++ for domain decomposed simulations, an alternative C++ build was implemented in the \texttt{profile} directory. This build uses a standard C++ Makefile and sample C++ inputs are provided as well. This alternative build might also be advantageous for developers that would like quick turnaround between updates in the core OpenMOC code rather than having to re-install OpenMOC after each source code update. 

The downside of using the C++ build is that a C++ input file is required, which can be quite inflexible compared with regular scripting languages such as Python. This difficulty mainly arises during geometry and material definitions. Therefore, new routines were created that save the geometry and material descriptions to a geometry binary file (usually with the *.geo extension). The file can then be easily loaded in either Python or C++ using the OpenMOC geometry reader. This allows the user to take advantage of both the flexibility of the Python build for inputs and the C++ build for universality and ease of installation. This process of creating geometry and material definitions in Python while running the simulations using the C++ build was used for the vast majority of the results presented in this Thesis.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Version Control and Licensing}
\label{sec:version-control}

OpenMOC utilizes Git version control and an open source distribution is hosted on GitHub at \url{https://github.com/mit-crpg/OpenMOC.git}. Git is a free and open source version control distribution that is becoming the software industry standard for version control. GitHub uses the Git distribution to host software distributions, both open source and closed source. Pull requests to the \textit{develop} branch form the basis by which the code evolves. Anyone in the public can contribute to the code by making a pull request to the develop branch. The work presented in this thesis is found on the \textit{3DMOC} branch, which has not yet been merged with the \textit{develop} branch since it does not contain all the functionality currently available on the \textit{develop} branch for 2D MOC simulations.

The OpenMOC code has been approved for open source release by the MIT Technology Licensing Office (TLO) under the MIT/X license. This license allows anyone to download the software without restriction. In addition, modifications to the software may be published, distributed, or sold. OpenMOC is designed with the intent of experimenting with new ideas within MOC simulations. This is further aided by the new flexible structure detailed in this chapter. The goal of OpenMOC is to promote an active reactor physics community where transparent research is possible and new ideas encourage the improvement of nuclear reactor modeling and simulation.