\chapter{Ray Tracing}
\label{chap:ray-tracing}

In the previous chapter, track generation was discussed. Once the tracks are laid across the geometry, they need to be partitioned by source region intersections into segments across which the MOC equations can be applied. At a minimum, the segment lengths and associated source region identifiers need to be recorded for each track. During the transport sweep, the MOC equations described in Chapter~\ref{chap:moc} are applied to all segments. This chapter discusses ray tracing procedures in which the segments are formed from the track and geometry information. Section~\ref{sec:rt-intro} provides an introduction of common ray tracing schemes and their implications. In Section~\ref{hi}.

FIXME


\section{Introduction to Ray Tracing}
\label{sec:rt-intro}

Ray tracing fundamentally solves the problem of determining the next intersection with a surface along the direction of travel and which new region is entered after the intersection. Since complicated geometries contain many surfaces, this step can be expensive if all surfaces in the geometry need to be tested for intersections. Much of the work in complex ray tracing for animations relies on somehow forming \textit{acceleration structures} which limit the number of surfaces that need to be tested~\cite{acceleration-structures}. Traditional methods rely on forming acceleration structures that resemble some hierarchy of cells and surfaces in order to only consider nearby surfaces~\cite{acc-struct-hierarchy}.

In traditional reactor physics problems, an acceleration structure is naturally formed by the hierarchical structure of the geometry. For instance, a core can largely be viewed as an arrangement of assemblies, each of which is comprised of an arrangement of fuel rods. Therefore, by just using the hierarchical CSG form of the geometry, the ray tracing requirements are naturally reduced.

However, ray tracing can still be expensive, especially for cases which do not form an easily structured form, such as reactor baffles, grid spacers, and neutron shields. These complexities cause a generic algorithm capable of treating all the reactor detail to lose computational efficiency. In moving from 2D simulations to 3D simulations, even more surfaces are introduced, exacerbating the issue.
	
Most MOC implementations avoid this issue by treating ray tracing as a pre-processing step whereby the segment information is explicitly stored at the beginning and then loaded during the transport sweep. In this way  the amount of repeated ray tracing work is reduced and the cost of ray tracing is effectively amortized over the number of transport sweeps. While this approach is straightforward, its memory and compute requirements for 3D MOC can be prohibitive, even for small problems, due to the vast number of segments present in 3D MOC simulations. Reducing the memory footprint is important for many reasons including improved cache efficiency and reducing bulk memory requirements.

In this thesis, an alternative approach is presented that greatly reduces the segment storage and generation requirements by taking advantage of the extruded geometry structure common to many reactor physics problems. This alternative approach saves no 3D segment data, rather treating the ray tracing problem as a coupled 2D and 1D system whereby 2D radial ray tracing information is combined with 1D axial information to compute the 3D intersections~\cite{physor2016}.

Another ray tracing scheme, termed the the Chord Classification Method (CCM)~\cite{Sciannandrone2015}, also sought to reduce the memory requirements for ray tracing axially extruded geometries by only saving the unique chords (or segments).  However, this method still requires that the segmentation procedure be performed for all 3D tracks prior to performing transport sweeps, which can be prohibitively expensive for complex geometries. In addition, while it does indeed reduce the storage requirements, the storage scales with the number of unique 3D segment lengths. This can be problematical for problems in which there are a large number of unique segments. For large full core problems, some regions might indeed have many repeated segment lengths, but regions for which the source height is similar to the axial ray spacing, there would be very few repeated segment lengths.

The implementation in this thesis aims to most efficiently solve typical PWR problems. From experience in simulating single PWR assemblies, the axial ray separation can be on the same order as the axial source height~\cite{mc2017}, potentially causing there to be a large number of unique segments. This motivates using concepts from the CCM method to identify repeated segment lengths but the 2D/1D ray tracing approach for storage.  This discussion will be presented in terms of handling flat source regions (FSRs) but the implementation is also valid for handling regions with a linear source approximation. 

\section{Forming an Axially Extruded Geometry}

As previously stated, OpenMOC only supports piece-wise axially extruded geometries. Most common reactor problems are naturally defined as piece-wise axially extruded so this is not a strong limitation in practice. Here, an axially extruded geometry is defined to be a geometry in which every radial slice of the reactor geometry is identical whereas a piece-wise axially extruded geometry can be defined as the collection of a finite number of axial zones where the geometry over each axial zone constitutes an extruded geometry. 

For ray tracing in a 2D/1D scheme, a single axially extruded extruded geometry is required. Therefore, all radial detail must be gathered in order to effectively convert the piece-wise axially extruded geometry to an axially extruded geometry. While common reactor cores contain variations from axially extruded geometries, such as end plugs for control rods, these variations can be fully captured at little cost by implicitly inserting additional geometric intersections. 

Note the axially extruded requirement is one only on the geometry, not the materials. Given an axially extruded geometry, it is possible to store only the 2D segments associated with intersections in the radial geometry. The 3D segments can then be formed on-the-fly using a simple axial mesh.

First, 2D segments need to be formed which reflect intersections of the 2D tracks with a superposition of all radial surfaces in the geometry. This is done by simultaneously ray tracing across all the unique radial planes in the geometry, as depicted in Fig.~\ref{fig:superposition}. This creates an implicit geometry containing all radial information, termed the \textit{superposition plane}. The 2D geometric regions in the superposition plane correspond to an axially extruded region with an associated unique identifier that contains an axial mesh and an array of associated 3D FSRs. 

\begin{figure}[ht!]
	\centering
	\includegraphics[width=\linewidth]{figures/ph2016/new_unique_z_levels_v_extruded_rt2.png}
	\caption{Depiction of 2D ray tracing for superposition of all radial detail.}
	\label{fig:superposition}
\end{figure}

Each 2D segment formed during the ray tracing contains its length and the unique identifier of the axially extruded region being traversed. After 2D segmentation, axial meshes need to be created for on-the-fly axial ray tracing. If a global axial mesh is desired, whereby all axially extruded regions have the same axial mesh, all the unique z-planes in the geometry are collected and sorted into an axial mesh. Otherwise, local meshes are populated for each axially extruded region during initialization of the 3D FSRs. To initialize the 3D FSRs, a temporary vertical ray is created for each axially extruded region. These rays all start from the bottom of the root geometry and are directed upwards and segmented to determine distances between axial intersections and initialize the associated FSR. During this step, the location of a point within the FSR is noted, and the data structures associated with managing the FSRs are initialized. An illustration of this process is presented in Fig.~\ref{fig:fsr-initialization}.

\begin{figure}[h!]
	\centering
	\begin{subfigure}[b]{0.25\textwidth}
		\centering
		\includegraphics[width=\linewidth]{figures/ph2016/fsr-init-a.PNG}
		\caption{}
		\label{fig:fsr-init-a}
	\end{subfigure}
	\begin{subfigure}[b]{0.28\textwidth}
		\centering
		\includegraphics[width=\linewidth]{figures/ph2016/fsr-init-b.PNG}
		\caption{}
		\label{fig:fsr-init-b}
	\end{subfigure}
	\begin{subfigure}[b]{0.4\textwidth}
		\centering
		\includegraphics[width=\linewidth]{figures/ph2016/fsr-init-c.PNG}
		\caption{}
		\label{fig:fsr-init-c}
	\end{subfigure}
	\caption[]{Illustration of FSR initialization starting from the superposition plane (a) where a radial point is chosen in each unique region, vertical tracks (b) are generated at the chosen points to map the axial detail, yielding (c) the 1D axial meshes for each region, and (optionally) a global 1D axial mesh}
	\label{fig:fsr-initialization}
\end{figure}

Implicitly, this strategy can create extra radial intersections since some of the axial levels might not have originally contained the full radial detail of the superposition plane. However, the number of additional intersections should be low due to the regular structure of most reactor cores. For instance, fuel rods with end plugs present only a slight deviation from an axially extruded geometry.

The advantage of local axial meshes is the ability to have different axial refinements within the reactor. For instance, a partially inserted control rod might need a finer FSR discretizations near the control rod tip. If a global axial mesh were used, the finer discretization would need to be applied to the whole core at that axial height, including the reflector. With local axial meshes, only the regions which need refinement would use a finer discretization.

\section{On-the-fly Axial Ray Tracing}

During the transport sweeps, each 3D track is traversed until it reaches its end point on a geometry bounding surface. The common method mentioned in Section~\ref{sec:rt-intro} accomplishes this by splitting every 3D track into 3D segments before the transport sweeps and then simply cycling through all the segments of the track sequentially.

In the methods presented here, 3D segments are recreated on-the-fly for each 3D track using the 2D ray trace over all radial detail and the 1D axial meshes formed at the beginning of the simulations. Due to the manner in which the 3D tracks were generated, as detailed in Chapter~\ref{chap:track-laydown}, each 3D track has a corresponding 2D segmented track. From the starting $z$ coordinate of a track along with its polar angle, it is possible to determine the distance along the track to both intersections with axial planes and intersections with 2D surfaces, defined by the 2D segments. On-the-fly axial ray tracing can either be performed on each 3D track individually or on an entire $z$-stack.

\subsection{Ray Tracing Individual 3D Tracks}

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.75\linewidth]{figures/ph2016/otf_ray_tracing.png}
	\caption{Illustration of the on-the-fly axial ray tracing process with axial intersections colored in blue and radial intersections colored in red. For the chosen track, the distance to the next axial intersection is denoted $L_z$ and the the distance to the next radial intersection is denoted $L_s$.}
	\label{fig::otf_ray_tracing}
\end{figure}

For ray tracing each 3D track individually, the associated 2D segments are traversed until the 3D track reaches its endpoint. First, the starting point is used to determine the appropriate starting 2D segment and index into the axial mesh. If local meshes are used, the index needs to be recomputed with a binary search at the start of each 2D segment. If a global mesh is used, the axial index only needs to be calculated at the beginning of the track. The 2D segments are traversed and the shorter distance to either an axial or radial intersection is calculated. This computed distance is the 3D segment length and has an associated 3D FSR indicated by the axial index. To form the next 3D segment, the position along the 2D track is moved by the appropriate distance. This process is repeated until the endpoint is reached. An illustration of this concept is presented in Fig.~\ref{fig::otf_ray_tracing}.



\subsection{Ray Tracing 3D Track $z$-Stacks}

The structure of the 3D track laydown can be used to ray trace an entire $z$-stack. Specifically all tracks in the $z$-stack have the same polar angle $\theta$, project onto the same 2D track, and are separated by a constant axial ray spacing $\delta z$. Therefore, if we define $z_0(0)$ as the $z$-coordinate at the intersection of the lowest track with the $z$-axis at the start of the associated 2D track, the axial height $z_i$ of the $i^{\textit{th}}$ lowest track (starting from 0) can be defined as

\begin{equation}
z_i(s) = z_0(0) + i\delta z + s \cot{\theta}
\label{eq::track_projection}
\end{equation}
where $s$ is the distance along the associated 2D track. Combining this with 2D track information is enough to completely describe the trajectory and location of 3D tracks in the stack. Therefore, it is possible to determine which tracks will traverse a given FSR.

For each 2D segment in the 2D track, there is an associated axially extruded region which contains a list of 3D FSRs in the region. To trace a $z$-stack, intersections within axially extruded FSRs are determined in the order traversed by the 2D segments. The 1D axial mesh (either local or global) associated with the axially extruded region is used to determine the axial boundaries of each 3D FSR. Using the boundaries of the FSR and Eq.~\ref{eq::track_projection}, it is possible to analytically compute the indexes of tracks that will cross the FSR as
\begin{equation}
i_{\textit{start}} = \Bigg\lceil\frac{z_{\textit{min}} - \max\left({z_0(s_{\textit{start}}), z_0(s_{\textit{end}})}\right) }{\delta z}\Bigg\rceil
\label{eq::start_track}
\end{equation}
\begin{equation}
i_{\textit{end}} = \Bigg\lfloor\frac{z_{\textit{max}} - \min\left({z_0(s_{\textit{start}}), z_0(s_{\textit{end}})}\right) }{\delta z}\Bigg\rfloor
\label{eq::end_track}
\end{equation}
where $i_{\textit{start}}$ is the index of the first track to cross the FSR, $i_{\textit{end}}$ is the index of the last track to cross the FSR, $s_{\textit{start}}$ is the 2D distance traversed at the start of the segment and $s_{\textit{end}}$ is the 2D distance traversed at the end of the segment. A depiction of this process is shown in Fig.~\ref{fig::stack_tracing}.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.75\linewidth]{figures/ph2016/stack_tracing.png}
	\caption{Illustration of the on-the-fly axial ray tracing process for an entire $z$-stack. The green arrows denote the first track to traverse the highlighted FSRs calculated by Eq.~\ref{eq::start_track} and the red arrows denote the last tracks to traverse the FSRs calculated by Eq.~\ref{eq::end_track}.}
	\label{fig::stack_tracing}
\end{figure}


Notice that for FSR A depicted in Fig.~\ref{fig::stack_tracing} there are multiple track segments that cross the entire 2D length of the FSR and are therefore identical. Their 3D segment length $L_{3D}$ would simply be
\begin{equation}
L_{3D} = \frac{s_{\textit{end}} - s_{\textit{start}}}{\sin{\theta}}.
\end{equation}

In common reactor physics problems we expect this effect to be much more pronounced. Due to the radial direction having much greater complexity than the axial direction, FSRs will tend to be longer in the axial direction than in the radial plane, especially when higher order sources are added in the axial direction. The high aspect ratio causes some tracks to cross the entire 2D length of the FSR.

To take advantage of this, it is possible to calculate the indexes of the first and last tracks to traverse the entire 2D segment length. For this condition to be met, the axial height of the tracks over the entire 2D segment must be greater than the minimum axial boundary of the FSR and less than the maximum axial boundary. Therefore, the indexes of interest are the first track to have its lowest point above the minimum boundary and the first track to have its highest point above the maximum boundary. We name this indexes $i_{\textit{in}}$ and $i_{\textit{out}}$ respectively and they can be calculated as:

\begin{equation}
i_{\textit{in}} = \Bigg\lceil\frac{z_{\textit{min}} - \min\left({z_0(s_{\textit{start}}), z_0(s_{\textit{end}}})\right) }{\delta z}\Bigg\rceil
\end{equation}

\begin{equation}
i_{\textit{out}} = \Bigg\lceil\frac{z_{\textit{max}} - \max\left({z_0(s_{\textit{start}}), z_0(s_{\textit{end}}})\right) }{\delta z}\Bigg\rceil
\end{equation}

For each FSR these indexes are calculated along with those beginning and end track indexes given in Eq.~\ref{eq::start_track} and Eq.~\ref{eq::end_track}. It is possible that $i_{\textit{in}}$ will be greater than $i_{\textit{out}}$ when the polar angle is steep enough, allowing for the FSR to be fully traversed axially without traversing the entire 2D length. These tracks can be determined with indexes $i_{\textit{in}}$ and $i_{\textit{out}}$ and have a common 3D segment length $L_{3D}$ given by
\begin{equation}
L_{3D} = \frac{z_{\textit{max}} - z_{\textit{min}}}{\left| \cos{\theta}\right|}.
\end{equation}

Therefore, 3D segments are classified into four categories:

\begin{itemize}
	\item \textbf{Mixed Tracks -- Case A:} Tracks that partially traverse the FSR and cross the lower FSR boundary. They are defined by track indexes $i_{\textit{start}} \leq i < \min\left(i_{\textit{in}}, i_{\textit{out}}\right)$. For these tracks, each 3D segment is computed individually. 
	\item \textbf{Mixed Tracks -- Case B:} Tracks that partially traverse the FSR and cross the upper FSR boundary and each 3D segment is again computed individually. They are defined by track indexes $\max\left(i_{\textit{in}}, i_{\textit{out}}\right)  \leq i  \leq i_{\textit{end}}$.
	\item \textbf{Horizontal Tracks:} Tracks that fully traverse the entire 2D radial distance of the FSR and are defined by indexes $i_{\textit{in}} \leq i < i_{\textit{out}}$. 
	\item \textbf{Vertical Tracks:} Tracks that traverse the entire axial distance of the FSR and are defined by $i_{\textit{out}} \leq i < i_{\textit{in}}$.
\end{itemize}

vvvv FIXME: remove? vvvv

\section{Applying the MOC Equations}
The 3D segments that are computed from the axial on-the-fly ray tracing can either be stored in temporary arrays of segments or directly used to apply Eq.~\ref{eq::fsr_attenuation} to the associated track's angular flux and Eq.~\ref{eq::scalar_flux} to the associated FSR as they are formed. In MOC, it is common to have each track represent both a forward and backward angular flux to maximize efficiency and reduce the amount of book keeping associated with each angular flux. 

The advantage to temporarily storing segments is that ray tracing would only need to be performed in the forward direction along each track. Once the segments are stored in the temporary arrays, the MOC equations presented in Eq.~\ref{eq::fsr_attenuation} and Eq.~\ref{eq::scalar_flux} can be applied forward to the stored segments and then backward, representing the forward and backward angular fluxes. The temporary arrays are created at the beginning of the solver. For on-the-fly axial ray tracing by individual 3D track, one temporary array of segments needs to be created of size $S$ equal to the maximum number of segments per 3D track. For on-the-fly axial ray tracing by $z$-stack, the $M$ temporary arrays of segments need to be created of size $S$ where $M$ is the maximum number of tracks per $z$-stack.

Alternatively, if the segments are used in Eq.~\ref{eq::fsr_attenuation} and Eq.~\ref{eq::scalar_flux} immediately after formation, ray tracing needs to be performed both forward and backward along the tracks. This additional ray tracing cost should make this alternative method more expensive for ray tracing by individual 3D tracks. However for ray tracing by $z$-stacks, there will be increased cache efficiency from tracks that tally scalar flux contributions to the same FSR. In practice, FSRs are allocated continuously in memory by axial level so there is the potential of cache reuse from this method coupled with ray tracing by $z$-stacks. Because of this reasoning, results will only be shown for this method tested with ray tracing by $z$-stacks.

\section{RESULTS}

The methods described above were implemented into OpenMOC\cite{openmoc}, an open source MOC solver. Performance results are presented for the OpenMOC solver with the various different ray tracing schemes. All performance results were gathered from jobs submitted on Amazon Web Services' (AWS) Elastic Compute Cloud (EC2) on m4.10xlarge nodes which each have 40 CPU cores and 160 GB RAM.

\subsection{Description of Test Problem}
To test the different approaches to 3D MOC segment formation, a single test problem is chosen to represent the type of geometries encountered in reactor core simulations. Specifically, the central UO$_{\text{2}}$ assembly of the 3D C5G7 Benchmark Unrodded geometry was used with reflective boundaries on all surfaces except the top axial surface, which has a vacuum boundary. A detailed description of additional test problem parameters is given in Table~\ref{tab::problem}.

\begin{table}[ht]
	\centering
	\caption{Test Problem Parameters}
	\medskip
	\begin{tabular}{|l|c|}
		\hline
		Assembly width &  $21.42 \text{cm} \times 21.42 \text{cm}$\\
		Assembly height & 64.26 cm\\
		Pin Configuration &  $17\times 17$\\
		Number of Sectors per Pin Cell & 8 \\
		Number of Rings in Fuel &  3 \\
		Number of Rings in Moderator & 2 \\
		Height of Flat Source Regions & 7.14 cm \\
		Azimuthal ray spacing & 0.1 cm \\
		Polar Ray Spacing & 0.1 cm \\
		Number of Azimuthal Angles & 16 \\
		Number of Polar Angles & 6 \\
		Number of Transport Sweeps & 20 \\
		\hline
	\end{tabular}
	\label{tab::problem}
\end{table}

To truly converge this problem, a finer discretization is needed for both the tracks and flat source regions. In this paper, the focus is performance results and no converged solutions are presented. The number of transport sweep iterations is fixed at 20, which is far from convergence without CMFD acceleration. However, the parameters used in this study should be reasonably demonstrate the computation encountered for ray tracing in reactor core geometries. A separate study~\cite{sam_new} was performed for verification of the MOC solver. Fig.~\ref{fig::FSRs} plots the projection of the FSRs on both the $x$-$y$ and $x$-$z$ planes.


\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.75\linewidth]{figures/ph2016/fsrs.png}
	\caption{Flat source region discretization of the test problem. Pin cells are divided into 8 sectors with three rings in the fuel and two in the moderator, each with a height of 7.14 cm.}
	\label{fig::FSRs}
\end{figure}


\subsection{Performance Results}
Several cases were run on single AWS m4.10xlarge compute nodes using the different techniques described in this paper. The list of cases is given in Table~\ref{tab::cases}, ordered by their computational time for the eigenvalue calculation. 

\begin{table}[ht]
	\centering
	\caption{Descriptions for the ray tracing schemes tested in OpenMOC.}
	\begin{tabular}{c m{10cm}}
		\toprule
		\textbf{Case Number} & \textbf{Description} \\
		\midrule
		1 & On-the-fly stack ray tracing with temporary segment storage and local axial meshes \\
		2 & On-the-fly stack ray tracing with temporary segment storage and a global axial mesh \\
		3 & Explicit 3D segment storage \\
		4 & On-the-fly ray tracing by individual 3D track with a global axial mesh\\
		5 &On-the-fly ray tracing by individual 3D track with local axial meshes\\
		6 & On-the-fly stack ray tracing with direct MOC equations and local axial meshes \\
		7 & On-the-fly stack ray tracing with direct MOC equations and a global axial mesh \\
		\bottomrule
	\end{tabular}
	\label{tab::cases}
\end{table}


Note that the timing results do not include the time required to lay down 3D tracks or segment tracks before the beginning of the transport sweeps. Only the computational time to complete the 20 transport sweeps is counted. If the total run time were instead presented, explicit 3D segments would perform far worse since the time required to segment the tracks before the transport sweeps can be substantial. Still, the best on-the-fly methods actually outperform the explicit 3D segments in this study. A detailed description of the performance results for each case are presented in Tab.~\ref{tab::performance_results}.


\begin{table}[ht]
	\centering
	\caption{Computational results from the C5G7 single assembly test problem with several different ray tracing schemes in OpenMOC.}
	\begin{tabular}{ccc}
		\toprule
		\textbf{Case Number} & \textbf{Computation Time (s)} & \textbf{Total Memory (GB)} \\
		\midrule
		1  & 391.85 +/- 4.50 & 4.522 \\
		2  & 392.40 +/- 2.99 & 4.523 \\
		3  & 394.97 +/- 6.37 & 79.00 \\
		4  & 401.61 +/- 3.32 & 4.359 \\
		5  & 427.41 +/- 3.30 & 4.269 \\
		6  & 537.85 +/- 6.10 & 4.274 \\
		7  & 539.27 +/- 2.75 & 4.343 \\
		\bottomrule
	\end{tabular}
	\label{tab::performance_results}
\end{table}


The computational time for the different scheme was calculated by running each case 3 times on 6 different m4.10xlarge nodes. The median computational time was taken from each node and averaged across the six test nodes to provide the mean computation time and standard deviation, which was taken to be the uncertainty in the result. Total memory presented is the physical memory used by the OpenMOC.

Notice that the memory usage of explicit segmentation (case number 3) is more than an order of magnitude greater than the memory required for any of the on-the-fly axial ray tracing schemes. The computation times of the on-the-fly ray tracing schemes by $z$-stack with temporary segment storage are better than that with explicit segments, but the difference is well within the uncertainty associated with the results. The axial ray tracing schemes by individual 3D tracks are slightly slower, with the global axial mesh option being significantly faster than local meshes due to the lack of the need for a binary search on each new 2D segment. 

The axial ray tracing schemes by $z$-stack with direct application of the MOC equations perform the worst, likely due to the need for performing on-the-fly segmentation twice on each $z$-stack during a transport sweep. However, it is important to note that if higher order sources were added this scheme might become more attractive with more relative computational time being spent on applying the MOC equations to the track angular fluxes and FSR scalar fluxes than on actual ray tracing.

\begin{figure}[ht!]
	\centering
	\includegraphics[width=0.75\linewidth]{figures/ph2016/scaling.png}
	\caption{Strong scaling results for the various ray tracing schemes on the C5G7 single assembly test problem.}
	\label{fig::scaling}
\end{figure}

Parallel scaling results are presented in Fig.~\ref{fig::scaling}. Notice that all the ray tracing schemes have similar parallel scaling performance during the transport sweeps. While the scaling is far from ideal, it is not saturated even at 40 cores. In more standard high performance computing, the scaling results would likely be far better, such as that observed for OpenMOC on BlueGene/Q\cite{will}.





%A description of this modified algorithm is presented in Algorithm~\ref{alg::new}.

%\begin{algorithm*}[!h]
%\caption{3D MOC algorithm extending the standard 2D approach}
%\label{alg::new}
%\begin{algorithmic}
%\STATE User specifies materials and a geometry
%\STATE Generate tracks across the geometry
%\STATE Create a superposition plane that contains all radial divisions
%\FORALL{$i \in \text{2D tracks}$}
%    \STATE Segment 2D track $i$ into 2D segments across the superposition plane, saving     the 2D segment lengths and corresponding axially extruded region identifiers,          populating the axially extruded regions as new regions are traversed
%\ENDFOR
%\FORALL{$A \in \text{axially extruded regions}$}
%    \STATE Create a vertical track in $A$ and segment the track through the 3D geometry, populating the 3D FSRs and saving their identifiers to $A$
%\ENDFOR
%\FORALL{transport sweeps}
%    \FORALL{$i \in \text{2D tracks}$}
%      \FORALL{$\theta \in \text{polar angles}$}
%        \FORALL{$t \in \text{z-stack for 2D track } i \text{ and polar angle } \theta$}
%           \FORALL{$s \in \text{2D segments for track } i$}
%               \STATE Determine the 3D segment on-the-fly by calculating whether a radial intersection defined by the 2D segment or an axial intersection defined by the axial mesh associated with $s$ is reached first
%                \STATE Apply Eq.~\ref{eq::fsr_attenuation} and Eq.~\ref{eq::scalar_flux} to track $t$ and the corresponding FSR
%                \ENDFOR
%            \ENDFOR
%        \ENDFOR
%    \ENDFOR
%    \IF{Source is converged} 
%        \RETURN
%    \ENDIF
%\ENDFOR
%\end{algorithmic}
%\end{algorithm*}




%------------------------------------------------------------------------------
%
%------------------------------------------------------------------------------
\section{CONCLUSION} 

In this study, an alternative approaches to 3D MOC were presented for segment storage whereby only 2D segments are stored and 3D segments are computed on-the-fly. This approach offers significant memory reduction with minimal or no computational overhead. Results show that the most efficient ray tracing tested was ray tracing entire $z$-stacks of 3D tracks with temporary storage of the computed segments.
\clearpage

\vfill
\begin{highlightsbox}[frametitle=Highlights]
\begin{itemize}
  \item The bias between OpenMC and OpenMOC is the result of the flux separability approximation which uses the scalar rather than the angular flux to collapse the total \ac{MGXS} in energy and space.
  \item The most rigorous solution would require the use of angular-dependent total \ac{MGXS}. However, most deterministic multi-group methods, including OpenMOC, are not equipped to use angular-dependent \ac{MGXS}.
  \item \ac{SPH} factors are introduced here as one approach to force reaction rate preservation in multi-group methods which use \ac{MC}-generated \ac{MGXS}.
  \item The \ac{SPH} factor scheme corrects the total \ac{MGXS} to enforce neutron balance with a reference fixed source computed from \ac{MC} tallies.
  \item The flux errors and eigenvalue bias between OpenMC and OpenMOC was largely resolved with \ac{SPH} factors for a 1D slab and 2D fuel pin.
  \item It is unclear if a generalizable scheme based upon \ac{SPH} factors may be used to correct for the flux separability approximation.
  \item Future work should investigate methods to account for the angular dependence of total \ac{MGXS} in order to adequately preserve reaction rates in fine-mesh transport methods with \ac{MC}-generated \ac{MGXS}.
\end{itemize}
\end{highlightsbox}
\vfill